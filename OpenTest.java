import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger;

public class OpenTest implements Command{
    String path;
    String name;
    //TODO refactor
    private Scanner scanner = new Scanner(System.in);
    Tests test;
    public OpenTest(){
        this.path = newName();
        this.name = path.substring(0, path.lastIndexOf('.'));
        //execute();
        String pathToSearch = "./tests/" + path;
        this.test = (Tests) File.files.stream()
                .filter(iter -> pathToSearch.equals(iter.getPath()))
                .findFirst()
                .orElse(null);
        System.out.println(test);
    }

    @Override
    public void execute() {
        ReadOrEdit();
        System.out.println(path);
        acceptingLink();
        //TODO linking from opening
    }


    public String checkTXT(String file){
        if(file.endsWith(".txt")){
            return file;
        }else{
            return file+".txt";
        }
    }


    public String newName(){
        System.out.println("Existing files are printed lower\n");
        File.files.stream()
                .filter(file -> file.getPath().startsWith("./tests/"))
                .forEach(System.out::println);
        System.out.println("Please, enter the name of the file you want to open\n" +
                "(you can write either type just filename or with \".txt\")");
        String res = checkTXT(scanner.next());
        if (Command.fileIsInDir(res,"./tests/")){
            return res;
        }else{
            System.out.println("Such file does not exist\n");
            newName();
        }
        return null;
    }


    public void ReadOrEdit(){
        System.out.println("Please, enter \"read\" if you want to read the file\n"+
                "or enter \"edit\" if you want to edit the file");
        switch (Inputs.toEnum(scanner.next())){
            case Inputs.READ:
                readFile();
                break;
            case Inputs.EDIT:
                editFile();
                break;
            default:
                //System.out.println("Invalid command, try again");
                ReadOrEdit();
        }
    }

    private void readFile() {
        try {
            Path file = Paths.get("./tests/" + path);
            Files.readAllLines(file)
                    .forEach(System.out::println);
        } catch (IOException e) {
            System.out.println("read file opentest");
            throw new RuntimeException(e);
        }
        stopEdit();
    }

    private void editFile() {
        System.out.println("You are in a file editing!");
        AtomicInteger count = new AtomicInteger(1);
        try {
            Path file = Paths.get("./tests/" + path);
            List<String> lines = Files.readAllLines(file);
            lines.forEach(iter -> System.out.println(count.getAndIncrement() + ": " + iter));
            System.out.println("Enter the line number you want to edit:");
            int lineNumber = scanner.nextInt();
            System.out.println("Enter the new content for the line:");
            Scanner scan = new Scanner(System.in);
            String newContent = scan.nextLine();
            lines.set(lineNumber - 1, newContent);
            Files.write(file, lines);
            addToFiles(lines);
            System.out.println("File edited");
            System.out.println("Input \"stop\" if you want to stop editing or \"continue\" if you want to continue");
            switch (Inputs.toEnum(scanner.next())){
                case Inputs.CONTINUE:
                    editFile();
                break;
                case Inputs.STOP:
                    break;
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private  void stopEdit(){
        System.out.println("Input \"stop\" to stop watching the file\n"+
                "or enter \"edit\" if you want to edit this file");
        switch (Inputs.toEnum(scanner.next())){
            case Inputs.STOP:
                break;
            case Inputs.EDIT:
                editFile();
                break;
            default:
                System.out.println("Invalid command, try again");
                stopEdit();
        }
    }

    public void addToFiles(List<String> list){
        String content = "";
        for(String iter : list){
            content += iter + "\n";
        }
        File.removeFromCollection(this.test);
        this.test.setContent(new ContentAnalysed(content));
        File.addToCollection(this.test);
    }
    public void acceptingLink(){
        System.out.println("If you want to link the task to the folder where the locations are created input \"link\"\n"+
                "or input stop if you dont want to link files");
        switch (Inputs.toEnum(scanner.next())){
            case LINK:
                linkToFolder();
                break;
            case STOP:
                break;
            default:
                System.out.println("Wrong command, try again");
                acceptingLink();
        }
    }
    public void linkToFolder(){
        System.out.println("Please enter the name of the student to which folder you want to link this test\n"+
                "or input \"stop\" if you want to stop linking");
        Scanner scan = new Scanner(System.in);
        String studentName = scan.nextLine();
        String path = "./Students/" + studentName;
        if(!fileExists(path)){
            System.out.println("Student does not exist");
            linkToFolder();
        }
        if(fileExists(path + "/" + name)){
            this.test.link(studentName + "/" + this.name);
            System.out.println("linked to " + this.test + "to " + path + "/" + this.name);
            linkToFolder();
        }else{
            System.out.println("Student has not provided solution for this task");
            linkToFolder();
        }
    }
    public boolean fileExists(String pathToF){
        Path path = Paths.get(pathToF);

        if (Files.exists(path)) {
            return true;
        } else {
            return false;
        }
    }
}
