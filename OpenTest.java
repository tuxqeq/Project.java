import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger;

public class OpenTest extends WrkngFiles<Tests>{
    public OpenTest(){
        newName();
        PrettyOutput.printHeader("You are in opening file section");
        ReadOrEdit();
        acceptingLink();
    }

    public void newName(){
        PrettyOutput.printInfo("Existing files are printed lower");
        File.files.stream()
                .filter(file -> file.getPath().startsWith("./tests/"))
                .forEach(System.out::println);
        PrettyOutput.printInfo("Please, enter the name of the test you want to open");
        PrettyOutput.print("(you can write either type just filename or with \".txt\")");
        String inp = removeTXT(PrettyOutput.next());
        if (testExists(inp)){
            this.name = inp;
            this.test = findTest(name);
        }else{
            PrettyOutput.printWarning("Such file does not exist");
            newName();
        }

    }

    public void ReadOrEdit(){
        PrettyOutput.printEnums(new Inputs[]{Inputs.READ, Inputs.EDIT});
        switch (Inputs.toEnum(PrettyOutput.next())){
            case Inputs.READ:
                readFile();
                break;
            case Inputs.EDIT:
                editFile();
                break;
            default:
                PrettyOutput.printWarning("Invalid command, try again");
                ReadOrEdit();
        }
    }

    private void readFile() {
        try {
            Path file = Paths.get("./tests/" + testTXT());
            Files.readAllLines(file)
                    .forEach(System.out::println);
        } catch (IOException e) {
            System.out.println("read file opentest");
            throw new RuntimeException(e);
        }
        stopEdit();
    }

    private void editFile() {
        System.out.println("You are in a file editing!");
        AtomicInteger count = new AtomicInteger(1);
        try {
            Path file = Paths.get("./tests/" + testTXT());
            List<String> lines = Files.readAllLines(file);
            lines.forEach(iter -> System.out.println(count.getAndIncrement() + ": " + iter));
            PrettyOutput.printBfInp("Enter the line number you want to edit:");
            Scanner scanner = new Scanner(System.in);
            int lineNumber = scanner.nextInt();
            String newContent = PrettyOutput.printBfInp("Enter the new content for the line:");
            lines.set(lineNumber - 1, newContent);
            Files.write(file, lines);
            addToFiles(lines);
            PrettyOutput.printInfo("File edited");
            PrettyOutput.printEnums(new Inputs[]{Inputs.STOP, Inputs.CONTINUE});
            switch (Inputs.toEnum(PrettyOutput.next())){
                case Inputs.CONTINUE:
                    editFile();
                break;
                case Inputs.STOP:
                    break;
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private  void stopEdit(){
        PrettyOutput.printEnums(new Inputs[]{Inputs.STOP, Inputs.EDIT, Inputs.CNTNT});
        switch (Inputs.toEnum(PrettyOutput.nextLine())){
            case Inputs.STOP:
                break;
            case Inputs.EDIT:
                editFile();
                break;
            case Inputs.CNTNT:
                PrettyOutput.printInfo("Content types:");
                PrettyOutput.print(this.test.content.printTypes());
                stopEdit();
                break;
            default:
                System.out.println("Invalid command, try again");
                stopEdit();
        }
    }

    public void addToFiles(List<String> list){
        StringBuilder content = new StringBuilder();
        for(String iter : list){
            content.append(iter).append("\n");
        }
        ColImp(this.test);
        this.test.setContent(new ContentAnalysed(content.toString()));
        addToCol(this.test);
    }
    @Override
    void ColImp(Tests obj) {
        File.files.remove(obj);
    }
}
