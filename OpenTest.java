import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger;

public class OpenTest extends WrkngFiles{
    //String name;
    //Tests test;

    public OpenTest(){
        newName();
        PrettyOutput.printHeader("You are in opening file section");
        ReadOrEdit();
        acceptingLink();
    }

    public static String checkTXT(String file){
        if(file.endsWith(".txt")){
            return file;
        }else{
            return file+".txt";
        }
    }

    public void newName(){
        PrettyOutput.printInfo("Existing files are printed lower");
        File.files.stream()
                .filter(file -> file.getPath().startsWith("./tests/"))
                .forEach(System.out::println);
        PrettyOutput.printInfo("Please, enter the name of the test you want to open");
        PrettyOutput.print("(you can write either type just filename or with \".txt\")");
        String inp = removeTXT(PrettyOutput.next());
        //String res = checkTXT(PrettyOutput.next());
        if (testExists(inp)){
            //this.path = res;
            this.name = inp;
            this.test = findTest(testTXT());
        }else{
            PrettyOutput.printWarning("Such file does not exist");
            newName();
        }

    }

    public void ReadOrEdit(){
        PrettyOutput.printEnums(new Inputs[]{Inputs.READ, Inputs.EDIT});
        switch (Inputs.toEnum(PrettyOutput.next())){
            case Inputs.READ:
                readFile();
                break;
            case Inputs.EDIT:
                editFile();
                break;
            default:
                PrettyOutput.printWarning("Invalid command, try again");
                ReadOrEdit();
        }
    }

    private void readFile() {
        try {
            Path file = Paths.get("./tests/" + testTXT());
            Files.readAllLines(file)
                    .forEach(System.out::println);
        } catch (IOException e) {
            System.out.println("read file opentest");
            throw new RuntimeException(e);
        }
        stopEdit();
    }

    private void editFile() {
        System.out.println("You are in a file editing!");
        AtomicInteger count = new AtomicInteger(1);
        try {
            Path file = Paths.get("./tests/" + testTXT());
            List<String> lines = Files.readAllLines(file);
            lines.forEach(iter -> System.out.println(count.getAndIncrement() + ": " + iter));
            PrettyOutput.printBfInp("Enter the line number you want to edit:");
            PrettyOutput<Integer> line = () -> {
                Scanner scanner = new Scanner(System.in);
                return scanner.nextInt();
            };
            int lineNumber = line.input();
            String newContent = PrettyOutput.printBfInp("Enter the new content for the line:");
            lines.set(lineNumber - 1, newContent);
            Files.write(file, lines);
            addToFiles(lines);
            PrettyOutput.printInfo("File edited");
            PrettyOutput.printEnums(new Inputs[]{Inputs.STOP, Inputs.CONTINUE});
            switch (Inputs.toEnum(PrettyOutput.next())){
                case Inputs.CONTINUE:
                    editFile();
                break;
                case Inputs.STOP:
                    break;
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private  void stopEdit(){
        PrettyOutput.printEnums(new Inputs[]{Inputs.STOP, Inputs.EDIT});
        switch (Inputs.toEnum(PrettyOutput.next())){
            case Inputs.STOP:
                break;
            case Inputs.EDIT:
                editFile();
                break;
            default:
                System.out.println("Invalid command, try again");
                stopEdit();
        }
    }

    public void addToFiles(List<String> list){
        StringBuilder content = new StringBuilder();
        for(String iter : list){
            content.append(iter).append("\n");
        }
        File.removeFromCollection(this.test);
        this.test.setContent(new ContentAnalysed(content.toString()));
        File.addToCollection(this.test);
    }

    /*public void acceptingLink(){
        System.out.println("If you want to link the task to the folder where the locations are created input \"link\"\n"+
                "or input stop if you dont want to link files");
        switch (Inputs.toEnum(scanner.next())){
            case LINK:
                linkToFolder();
                break;
            case STOP:
                break;
            default:
                System.out.println("Wrong command, try again");
                acceptingLink();
        }
    }*/
    /*public void linkToFolder(){
        System.out.println("Please enter the name of the student to which folder you want to link this test\n"+
                "or input \"stop\" if you want to stop linking");
        Scanner scan = new Scanner(System.in);
        String studentName = scan.nextLine();
        String path = "./Students/" + studentName;
        if(!fileExists(path)){
            System.out.println("Student does not exist");
            linkToFolder();
        }
        if(fileExists(path + "/" + name)){
            this.test.link(studentName + "/" + this.name);
            System.out.println("linked to " + this.test + "to " + path + "/" + this.name);
            linkToFolder();
        }else{
            System.out.println("Student has not provided solution for this task");
            linkToFolder();
        }
    }*/
    /*public static boolean fileExists(String pathToF){
        Path path = Paths.get(pathToF);
        return Files.exists(path);
    }*/
}
